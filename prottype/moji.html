<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>ç‰©ç†è½ä¸‹ã™ã‚‹æ–‡å­—</title>
<link rel="stylesheet" href="style.css">
</head>
<body>

<canvas id="world"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script src="config.js"></script>
<script src="physics.js"></script>
<script src="app.js"></script>
<script>
const { Engine, Render, Runner, Bodies, Composite } = Matter;

// ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ä½œæˆ
const engine = Engine.create();
const world = engine.world;

// æç”»è¨­å®š
const canvas = document.getElementById("world");
// 4:3ã®ç¸¦æ¨ªæ¯”ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
const aspectRatio = 4 / 3;
if (window.innerWidth / window.innerHeight > aspectRatio) {
  canvas.height = window.innerHeight;
  canvas.width = canvas.height * aspectRatio;
} else {
  canvas.width = window.innerWidth;
  canvas.height = canvas.width / aspectRatio;
}

Runner.run(Runner.create(), engine);

// åœ°é¢ã¨å£ï¼ˆåç™ºä¿‚æ•°ã‚’é«˜ãè¨­å®šï¼‰
const wallThickness = 40;
let ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight-20, window.innerWidth, wallThickness, { 
  isStatic: true,
  restitution: 0.5  // åç™ºä¿‚æ•°ï¼ˆè·³ã­è¿”ã‚Šã‚„ã™ã•ï¼‰
});
let leftWall = Bodies.rectangle(wallThickness/2, window.innerHeight/2, wallThickness, window.innerHeight, {
  isStatic: true,
  restitution: 0.5
});
let rightWall = Bodies.rectangle(window.innerWidth - wallThickness/2, window.innerHeight/2, wallThickness, window.innerHeight, {
  isStatic: true,
  restitution: 0.5
});
Composite.add(world, [ground, leftWall, rightWall]);

// ç”»é¢å¤–ã®å¢ƒç•Œï¼ˆã“ã®å¤–ã«å‡ºãŸã‚‰å‰Šé™¤ï¼‰
const boundaryMargin = 200;

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
window.addEventListener('resize', () => {
  // 4:3ã®ç¸¦æ¨ªæ¯”ã§ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’è¨­å®š
  const aspectRatio = 4 / 3;
  if (window.innerWidth / window.innerHeight > aspectRatio) {
    canvas.height = window.innerHeight;
    canvas.width = canvas.height * aspectRatio;
  } else {
    canvas.width = window.innerWidth;
    canvas.height = canvas.width / aspectRatio;
  }
  
  // åœ°é¢ã¨å£ã‚’æ›´æ–°
  Composite.remove(world, [ground, leftWall, rightWall]);
  ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight-20, window.innerWidth, wallThickness, { 
    isStatic: true,
    restitution: 0.5
  });
  leftWall = Bodies.rectangle(wallThickness/2, window.innerHeight/2, wallThickness, window.innerHeight, {
    isStatic: true,
    restitution: 0.5
  });
  rightWall = Bodies.rectangle(window.innerWidth - wallThickness/2, window.innerHeight/2, wallThickness, window.innerHeight, {
    isStatic: true,
    restitution: 0.5
  });
  Composite.add(world, [ground, leftWall, rightWall]);
});

// ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’è¿½è·¡
let mouseX = window.innerWidth / 2;
let mouseY = 50;

document.addEventListener("mousemove", (e) => {
  mouseX = e.clientX;
  mouseY = e.clientY;
});

// æ–‡å­—ã®å½¢çŠ¶ã‹ã‚‰é ‚ç‚¹ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°
function getTextVertices(char, fontSize = 32) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  
  const size = fontSize * 3;
  tempCanvas.width = size;
  tempCanvas.height = size;
  
  tempCtx.font = `bold ${fontSize}px sans-serif`;
  tempCtx.textAlign = 'center';
  tempCtx.textBaseline = 'middle';
  tempCtx.fillStyle = '#000';
  tempCtx.fillText(char, size / 2, size / 2);
  
  const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
  const data = imageData.data;
  
  // æ–‡å­—ã®å¢ƒç•Œã‚’æ¤œå‡º
  let minX = size, maxX = 0, minY = size, maxY = 0;
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const alpha = data[(y * size + x) * 4 + 3];
      if (alpha > 50) {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
    }
  }
  
  // å®Ÿéš›ã®æ–‡å­—ã‚µã‚¤ã‚ºï¼ˆä¸­å¿ƒã‹ã‚‰ã®åã‚Šã‚’è€ƒæ…®ï¼‰
  const width = Math.max(maxX - minX, fontSize * 0.3);
  const height = Math.max(maxY - minY, fontSize * 0.8);
  
  // æ–‡å­—ã®å®Ÿéš›ã®ä¸­å¿ƒä½ç½®ã‚’è¨ˆç®—
  const actualCenterX = (minX + maxX) / 2;
  const actualCenterY = (minY + maxY) / 2;
  const offsetX = actualCenterX - size / 2;
  const offsetY = actualCenterY - size / 2;
  
  // å½“ãŸã‚Šåˆ¤å®šã‚’ä¸€å›ã‚Šå¤§ããã™ã‚‹ï¼ˆ1.2å€ï¼‰
  const scale = 1.2;
  
  // æ–‡å­—ã®å½¢ã«åˆã‚ã›ãŸé ‚ç‚¹ã‚’ä½œæˆï¼ˆ16è§’å½¢ã§è¿‘ä¼¼ï¼‰
  const vertices = [];
  const sides = 16;
  for (let i = 0; i < sides; i++) {
    const angle = (i / sides) * Math.PI * 2;
    const radiusX = width / 2 * scale;
    const radiusY = height / 2 * scale;
    vertices.push({
      x: Math.cos(angle) * radiusX + offsetX,
      y: Math.sin(angle) * radiusY + offsetY
    });
  }
  
  return vertices;
}

// æ–‡å­—ã®çµ„ã¿åˆã‚ã›ã¨çµµæ–‡å­—ã®ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆ3æ–‡å­—ä»¥ä¸Šï¼‰
const emojiCombinations = {
  // æ„Ÿæƒ…ç³»
  'HAHA': 'ğŸ˜‚',
  'LOL': 'ğŸ¤£',
  'WOW': 'ğŸ˜®',
  'OMG': 'ğŸ˜±',
  'CRY': 'ğŸ˜¢',
  'LOVE': 'ğŸ˜',
  'ANGRY': 'ğŸ˜ ',
  'SLEEP': 'ğŸ˜´',
  
  // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç³»
  'OKAY': 'ğŸ‘Œ',
  'GOOD': 'ğŸ‘',
  'RUN': 'ğŸƒ',
  'WALK': 'ğŸš¶',
  'JUMP': 'ğŸ¤¸',
  'DANCE': 'ğŸ’ƒ',
  'CLAP': 'ğŸ‘',
  'WAVE': 'ğŸ‘‹',
  
  // è‡ªç„¶ç³»
  'SUN': 'â˜€ï¸',
  'MOON': 'ğŸŒ™',
  'STAR': 'â­',
  'RAIN': 'ğŸŒ§ï¸',
  'SNOW': 'â„ï¸',
  'FIRE': 'ğŸ”¥',
  'WATER': 'ğŸ’§',
  'TREE': 'ğŸŒ²',
  'FLOWER': 'ğŸŒ¸',
  'CLOUD': 'â˜ï¸',
  
  // é£Ÿã¹ç‰©ç³»
  'PIZZA': 'ğŸ•',
  'CAKE': 'ğŸ°',
  'APPLE': 'ğŸ',
  'BREAD': 'ğŸ',
  'BURGER': 'ğŸ”',
  'COFFEE': 'â˜•',
  'BEER': 'ğŸº',
  'SUSHI': 'ğŸ£',
  
  // å‹•ç‰©ç³»
  'CAT': 'ğŸ±',
  'DOG': 'ğŸ¶',
  'FISH': 'ğŸŸ',
  'BIRD': 'ğŸ¦',
  'LION': 'ğŸ¦',
  'TIGER': 'ğŸ¯',
  'BEAR': 'ğŸ»',
  'PANDA': 'ğŸ¼',
  
  // ãã®ä»–
  'HEART': 'â¤ï¸',
  'MUSIC': 'ğŸµ',
  'GAME': 'ğŸ®',
  'BOOK': 'ğŸ“š',
  'ROCKET': 'ğŸš€',
  'CAR': 'ğŸš—',
  'GIFT': 'ğŸ',
  'PARTY': 'ğŸ‰',
  
  // ç‰¹æ®Š
  'DELETE': 'DELETE', // ç‰¹æ®Šå‡¦ç†ç”¨
  
  // è‰²ç³»ï¼ˆèƒŒæ™¯è‰²å¤‰æ›´ç”¨ï¼‰
  'RED': 'COLOR_RED',
  'BLUE': 'COLOR_BLUE',
  'GREEN': 'COLOR_GREEN',
  'ORANGE': 'COLOR_ORANGE',
  'PURPLE': 'COLOR_PURPLE',
  'PINK': 'COLOR_PINK',
  'BLACK': 'COLOR_BLACK',
  'WHITE': 'COLOR_WHITE',
  'GRAY': 'COLOR_GRAY'
};

// éƒ¨åˆ†ä¸€è‡´ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
function checkPartialMatch(char) {
  // ã™ã¹ã¦ã®çµ„ã¿åˆã‚ã›ã‚’ãƒã‚§ãƒƒã‚¯
  for (let combo in emojiCombinations) {
    if (combo.includes(char)) {
      return true;
    }
  }
  return false;
}

// åˆæˆé€²è¡ŒçŠ¶æ³ã‚’ç®¡ç†
const mergingGroups = new Map(); // key: æ–‡å­—ã®ã‚»ãƒƒãƒˆ, value: {bodies, startTime, combo}
let deleteActive = false; // DELETEçŠ¶æ…‹ãƒ•ãƒ©ã‚°
let deleteStartTime = 0; // DELETEé–‹å§‹æ™‚åˆ»
let mergeDisplayText = ''; // åˆæˆæ™‚ã®è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
let mergeDisplayStartTime = 0; // åˆæˆè¡¨ç¤ºé–‹å§‹æ™‚åˆ»
let backgroundColor = '#fafafa'; // èƒŒæ™¯è‰²

// è‰²ã®ãƒãƒƒãƒ”ãƒ³ã‚°
const colorMap = {
  'COLOR_RED': '#ffcccc',
  'COLOR_BLUE': '#cce5ff',
  'COLOR_GREEN': '#ccffcc',
  'COLOR_ORANGE': '#ffe5cc',
  'COLOR_PURPLE': '#e5ccff',
  'COLOR_PINK': '#ffcce5',
  'COLOR_BLACK': '#333333',
  'COLOR_WHITE': '#ffffff',
  'COLOR_GRAY': '#cccccc'
};

// è¿‘ãã®æ–‡å­—ã‚’é›†ã‚ã¦çµ„ã¿åˆã‚ã›ã‚’ãƒã‚§ãƒƒã‚¯
function checkEmojiCombination() {
  const bodies = Composite.allBodies(world);
  const distance = 80; // åˆ¤å®šè·é›¢
  const mergeDelay = 200; // 2ç§’å¾Œã«åˆä½“
  const attractionForce = 0.0002; // å¼•ãåˆã†åŠ›
  
  const currentTime = Date.now();
  const processedBodies = new Set();
  
  // è¿‘ãã«ã‚ã‚‹æ–‡å­—ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
  for (let i = 0; i < bodies.length; i++) {
    const bodyA = bodies[i];
    if (!bodyA.renderSprite || bodyA.isStatic || bodyA.isEmoji || processedBodies.has(bodyA)) continue;
    
    let nearbyChars = [bodyA];
    let charString = bodyA.renderSprite;
    
    // bodyAã«è¿‘ã„ä»–ã®æ–‡å­—ã‚’æ¢ã™
    for (let j = 0; j < bodies.length; j++) {
      if (i === j) continue;
      const bodyB = bodies[j];
      if (!bodyB.renderSprite || bodyB.isStatic || bodyB.isEmoji || processedBodies.has(bodyB)) continue;
      
      const dx = bodyA.position.x - bodyB.position.x;
      const dy = bodyA.position.y - bodyB.position.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < distance) {
        nearbyChars.push(bodyB);
        charString += bodyB.renderSprite;
      }
    }
    
    // 3æ–‡å­—ä»¥ä¸Šé›†ã¾ã£ã¦ã„ã‚‹å ´åˆã€çµ„ã¿åˆã‚ã›ã‚’ãƒã‚§ãƒƒã‚¯
    if (charString.length >= 3) {
      for (let combo in emojiCombinations) {
        let usedBodies = [];
        
        for (let char of combo) {
          let found = false;
          for (let body of nearbyChars) {
            if (body.renderSprite === char && !usedBodies.includes(body)) {
              usedBodies.push(body);
              found = true;
              break;
            }
          }
          if (!found) {
            break;
          }
        }
        
        if (usedBodies.length === combo.length) {
          // ã™ã¹ã¦ã®ãƒœãƒ‡ã‚£ã‚’å‡¦ç†æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
          usedBodies.forEach(b => processedBodies.add(b));
          
          // ã‚°ãƒ«ãƒ¼ãƒ—IDã‚’ç”Ÿæˆï¼ˆãƒœãƒ‡ã‚£ã®IDã‚’ã‚½ãƒ¼ãƒˆã—ã¦çµåˆï¼‰
          const groupId = usedBodies.map(b => b.id).sort().join('-');
          
          // æ—¢å­˜ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‹ãƒã‚§ãƒƒã‚¯
          if (!mergingGroups.has(groupId)) {
            // æ–°ã—ã„ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ç™»éŒ²
            mergingGroups.set(groupId, {
              bodies: usedBodies,
              startTime: currentTime,
              combo: combo
            });
          } else {
            // æ—¢å­˜ã®ã‚°ãƒ«ãƒ¼ãƒ— - å¼•ãåˆã†åŠ›ã‚’é©ç”¨
            const group = mergingGroups.get(groupId);
            
            // ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—
            let centerX = 0, centerY = 0;
            for (let body of usedBodies) {
              centerX += body.position.x;
              centerY += body.position.y;
            }
            centerX /= usedBodies.length;
            centerY /= usedBodies.length;
            
            // å„ãƒœãƒ‡ã‚£ã‚’ä¸­å¿ƒã«å¼•ãå¯„ã›ã‚‹
            for (let body of usedBodies) {
              const dx = centerX - body.position.x;
              const dy = centerY - body.position.y;
              Matter.Body.applyForce(body, body.position, {
                x: dx * attractionForce,
                y: dy * attractionForce
              });
            }
            
            // ååˆ†ãªæ™‚é–“ãŒçµŒéã—ãŸã‚‰åˆä½“
            if (currentTime - group.startTime >= mergeDelay) {
              const emoji = emojiCombinations[combo];
              
              // DELETE ã®ç‰¹æ®Šå‡¦ç†
              if (combo === 'DELETE') {
                // å…ƒã®æ–‡å­—ã‚’å‰Šé™¤
                for (let body of usedBodies) {
                  Composite.remove(world, body);
                }
                
                // DELETEçŠ¶æ…‹ã‚’æœ‰åŠ¹åŒ–
                deleteActive = true;
                deleteStartTime = currentTime;
                
                // åœ°é¢ã‚’å‰Šé™¤
                if (ground) {
                  Composite.remove(world, ground);
                  ground = null;
                }
                
                mergingGroups.delete(groupId);
                return;
              }
              
              // è‰²ã®ç‰¹æ®Šå‡¦ç†
              if (emoji.startsWith('COLOR_')) {
                // èƒŒæ™¯è‰²ã‚’å¤‰æ›´
                backgroundColor = colorMap[emoji] || '#fafafa';
                
                // å…ƒã®æ–‡å­—ã‚’å‰Šé™¤
                for (let body of usedBodies) {
                  Composite.remove(world, body);
                }
                
                // åˆæˆè¡¨ç¤ºã‚’è¨­å®š
                mergeDisplayText = combo;
                mergeDisplayStartTime = currentTime;
                
                mergingGroups.delete(groupId);
                return;
              }
              
              // é€šå¸¸ã®çµµæ–‡å­—ã‚’ç”Ÿæˆ
              const vertices = getTextVertices(emoji, 48);
              const emojiBody = Bodies.fromVertices(centerX, centerY, vertices, {
                restitution: 0.7,
                friction: 0.001,
                render: {
                  fillStyle: "#fff",
                  strokeStyle: "#666",
                  lineWidth: 1
                }
              });
              
              emojiBody.renderSprite = emoji;
              emojiBody.isEmoji = true;
              
              // å…ƒã®æ–‡å­—ã‚’å‰Šé™¤
              for (let body of usedBodies) {
                Composite.remove(world, body);
              }
              
              Composite.add(world, emojiBody);
              
              // åˆæˆè¡¨ç¤ºã‚’è¨­å®š
              mergeDisplayText = combo;
              mergeDisplayStartTime = currentTime;
              
              mergingGroups.delete(groupId);
              
              return; // 1å›ã®æ›´æ–°ã§1ã¤ã ã‘å¤‰æ›
            }
          }
          
          break; // ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã¯å‡¦ç†å®Œäº†
        }
      }
    }
  }
  
  // è·é›¢ãŒé›¢ã‚ŒãŸã‚°ãƒ«ãƒ¼ãƒ—ã‚’å‰Šé™¤
  const groupsToDelete = [];
  for (let [groupId, group] of mergingGroups) {
    const { bodies: groupBodies } = group;
    
    // ãƒœãƒ‡ã‚£ãŒå‰Šé™¤ã•ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
    let allExist = true;
    for (let body of groupBodies) {
      if (!bodies.includes(body)) {
        allExist = false;
        break;
      }
    }
    
    if (!allExist) {
      groupsToDelete.push(groupId);
      continue;
    }
    
    // è·é›¢ãŒé›¢ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯
    let tooFar = false;
    for (let i = 0; i < groupBodies.length; i++) {
      for (let j = i + 1; j < groupBodies.length; j++) {
        const dx = groupBodies[i].position.x - groupBodies[j].position.x;
        const dy = groupBodies[i].position.y - groupBodies[j].position.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > distance * 1.5) {
          tooFar = true;
          break;
        }
      }
      if (tooFar) break;
    }
    
    if (tooFar) {
      groupsToDelete.push(groupId);
    }
  }
  
  groupsToDelete.forEach(id => mergingGroups.delete(id));
}

// å®šæœŸçš„ã«ãƒã‚§ãƒƒã‚¯
setInterval(checkEmojiCombination, 100);

// ã‚­ãƒ¼å…¥åŠ›ã§æ–‡å­—ã‚’è¿½åŠ 
document.addEventListener("keydown", (e) => {
  const char = e.key.toUpperCase(); // å¸¸ã«å¤§æ–‡å­—ã«å¤‰æ›
  if (char.length !== 1) return; // ç‰¹æ®Šã‚­ãƒ¼ã¯ç„¡è¦–
  
  const x = mouseX;
  const y = mouseY;

  const vertices = getTextVertices(char);
  
  const textBody = Bodies.fromVertices(x, y, vertices, {
    restitution: 0.7,
    friction: 0.001,
    render: {
      fillStyle: "#fff",
      strokeStyle: "#666",
      lineWidth: 1
    }
  });

  Composite.add(world, textBody);

  // ç‹¬è‡ªã«ãƒ†ã‚­ã‚¹ãƒˆã‚’æç”»ã™ã‚‹ãŸã‚ã®ãƒ•ãƒƒã‚¯
  textBody.renderSprite = char;
});

// æ–‡å­—ã®æç”»ã‚’ç‹¬è‡ªã«ã‚«ã‚¹ã‚¿ãƒ 
const ctx = canvas.getContext('2d');
(function drawText() {
  requestAnimationFrame(drawText);

  // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
  ctx.fillStyle = backgroundColor;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // ã™ã¹ã¦ã®ãƒœãƒ‡ã‚£ã‚’å–å¾—
  const bodies = Composite.allBodies(world);
  
  // ç”»é¢å¤–ã«å‡ºãŸæ–‡å­—ã‚’å‰Šé™¤
  const bodiesToRemove = [];
  for (let body of bodies) {
    if (!body.isStatic && body.renderSprite) {
      const pos = body.position;
      if (pos.x < -boundaryMargin || pos.x > canvas.width + boundaryMargin ||
          pos.y < -boundaryMargin || pos.y > canvas.height + boundaryMargin) {
        bodiesToRemove.push(body);
      }
    }
  }
  bodiesToRemove.forEach(body => Composite.remove(world, body));
  
  // å„æ–‡å­—ãŒã©ã®çµ„ã¿åˆã‚ã›ã§åå¿œã™ã‚‹ã‹ã‚’è¨ˆç®—
  const bodyHighlights = new Map(); // body -> boolean
  const validPairs = new Set(); // æœ‰åŠ¹ãªãƒšã‚¢ã®ã‚»ãƒƒãƒˆï¼ˆ"id1-id2"å½¢å¼ï¼‰
  const distance = 80;
  
  // ã™ã¹ã¦ã®å¯èƒ½ãªçµ„ã¿åˆã‚ã›ã‚’è©•ä¾¡
  const possibleCombos = [];
  
  // çµ„ã¿åˆã‚ã›ã”ã¨ã«å‡¦ç†
  for (let combo in emojiCombinations) {
    const chars = combo.split('');
    const requiredCount = combo.length >= 4 ? 3 : 2;
    
    // ã“ã®çµ„ã¿åˆã‚ã›ã«è©²å½“ã™ã‚‹æ–‡å­—ã‚’åé›†
    const candidateBodies = [];
    for (let body of bodies) {
      if (!body.renderSprite || body.isStatic || body.isEmoji) continue;
      if (chars.includes(body.renderSprite)) {
        candidateBodies.push(body);
      }
    }
    
    if (candidateBodies.length < requiredCount) continue;
    
    // æœ€é©ãªã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¦‹ã¤ã‘ã‚‹ï¼ˆå„æ–‡å­—ãŒ1å›ã ã‘ä½¿ã‚ã‚Œã‚‹ï¼‰
    // å¿…è¦ãªå„æ–‡å­—ã®ãƒªã‚¹ãƒˆ
    const neededChars = {};
    for (let char of chars) {
      neededChars[char] = (neededChars[char] || 0) + 1;
    }
    
    // æ–‡å­—ç¨®ã”ã¨ã«å€™è£œã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const charGroups = {};
    for (let char in neededChars) {
      charGroups[char] = candidateBodies.filter(b => b.renderSprite === char);
    }
    
    // ã™ã¹ã¦ã®çµ„ã¿åˆã‚ã›ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è©¦ã—ã¦å…¨ã¦ã®æœ‰åŠ¹ãªã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¦‹ã¤ã‘ã‚‹
    // ï¼ˆå†å¸°çš„ã«å…¨ã¦ã®å¯èƒ½ãªã‚°ãƒ«ãƒ¼ãƒ—ã‚’æ¢ã™ï¼‰
    function findAllGroups(charList, index, currentGroup, usedBodies, results) {
      // requiredCountä»¥ä¸Šæƒã£ã¦ã„ã‚Œã°ã€çµ‚ã‚ã‚Šã¾ã§è¡Œã‹ãªãã¦ã‚‚æœ‰åŠ¹
      if (index >= charList.length) {
        if (currentGroup.length >= requiredCount) {
          results.push([...currentGroup]);
        }
        return;
      }
      
      const char = charList[index];
      const count = neededChars[char];
      const availableBodies = charGroups[char].filter(b => !usedBodies.has(b));
      
      if (availableBodies.length < count) {
        // ã“ã®æ–‡å­—ç¨®ãŒè¶³ã‚Šãªã„å ´åˆã€ç¾åœ¨ã®ã‚°ãƒ«ãƒ¼ãƒ—ã§ååˆ†ã‹ç¢ºèª
        if (currentGroup.length >= requiredCount) {
          results.push([...currentGroup]);
        }
        findAllGroups(charList, index + 1, currentGroup, usedBodies, results);
        return;
      }
      
      // ã“ã®æ–‡å­—ç¨®ã‹ã‚‰å¿…è¦ãªæ•°ã ã‘é¸ã¶ã™ã¹ã¦ã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™
      const combinations = getCombinations(availableBodies, count);
      
      for (let combo of combinations) {
        const newGroup = [...currentGroup, ...combo];
        const newUsed = new Set([...usedBodies, ...combo]);
        
        // ç¾æ™‚ç‚¹ã§ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®è·é›¢ã‚’è¨ˆç®—
        let maxDist = 0;
        let validGroup = true;
        for (let i = 0; i < newGroup.length; i++) {
          for (let j = i + 1; j < newGroup.length; j++) {
            const dx = newGroup[i].position.x - newGroup[j].position.x;
            const dy = newGroup[i].position.y - newGroup[j].position.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            maxDist = Math.max(maxDist, dist);
            if (dist > distance) {
              validGroup = false;
              break;
            }
          }
          if (!validGroup) break;
        }
        
        if (!validGroup) continue;
        
        // å†å¸°çš„ã«æ¬¡ã®æ–‡å­—ã‚’é¸æŠ
        findAllGroups(charList, index + 1, newGroup, newUsed, results);
      }
    }
    
    // çµ„ã¿åˆã‚ã›ã‚’ç”Ÿæˆã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    function getCombinations(arr, count) {
      if (count === 1) return arr.map(item => [item]);
      if (count >= arr.length) return [arr];
      
      const results = [];
      for (let i = 0; i <= arr.length - count; i++) {
        const head = arr[i];
        const tailCombos = getCombinations(arr.slice(i + 1), count - 1);
        for (let tail of tailCombos) {
          results.push([head, ...tail]);
        }
      }
      return results;
    }
    
    const charList = Object.keys(neededChars);
    const allGroups = [];
    findAllGroups(charList, 0, [], new Set(), allGroups);
    
    // å…¨ã¦ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ possibleCombos ã«è¿½åŠ 
    for (let group of allGroups) {
      // ã‚°ãƒ«ãƒ¼ãƒ—ã®æœ€å¤§è·é›¢ã‚’è¨ˆç®—
      let maxDist = 0;
      for (let i = 0; i < group.length; i++) {
        for (let j = i + 1; j < group.length; j++) {
          const dx = group[i].position.x - group[j].position.x;
          const dy = group[i].position.y - group[j].position.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          maxDist = Math.max(maxDist, dist);
        }
      }
      
      possibleCombos.push({
        combo: combo,
        bodies: group,
        completeness: group.length,
        maxDistance: maxDist
      });
    }
  }
  
  // å…¨ã¦ã®æœ‰åŠ¹ãªçµ„ã¿åˆã‚ã›ã‚’é¸æŠï¼ˆè·é›¢ãŒè¿‘ã„é †ã«å„ªå…ˆã€ä½¿ç”¨æ¸ˆã¿ã®æ–‡å­—ã¯é™¤å¤–ï¼‰
  if (possibleCombos.length > 0) {
    possibleCombos.sort((a, b) => {
      if (b.completeness !== a.completeness) {
        return b.completeness - a.completeness;
      }
      return a.maxDistance - b.maxDistance;
    });
    
    // ä½¿ç”¨æ¸ˆã¿ã®ãƒœãƒ‡ã‚£ã‚’è¿½è·¡
    const usedBodies = new Set();
    
    // å„çµ„ã¿åˆã‚ã›ã‚’é †ã«å‡¦ç†
    for (let comboData of possibleCombos) {
      // ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã®å…¨ã¦ã®æ–‡å­—ãŒæœªä½¿ç”¨ã‹ãƒã‚§ãƒƒã‚¯
      const isAvailable = comboData.bodies.every(body => !usedBodies.has(body));
      
      if (isAvailable) {
        // é¸æŠã•ã‚ŒãŸæ–‡å­—ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        for (let body of comboData.bodies) {
          bodyHighlights.set(body, true);
          usedBodies.add(body); // ä½¿ç”¨æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
        }
        
        // ãƒšã‚¢ã‚’è¨˜éŒ²
        for (let i = 0; i < comboData.bodies.length; i++) {
          for (let j = i + 1; j < comboData.bodies.length; j++) {
            const bodyA = comboData.bodies[i];
            const bodyB = comboData.bodies[j];
            const pairId = bodyA.id < bodyB.id ? `${bodyA.id}-${bodyB.id}` : `${bodyB.id}-${bodyA.id}`;
            validPairs.add(pairId);
          }
        }
      }
    }
  }
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šåˆæˆå¯èƒ½ãªçµ„ã¿åˆã‚ã›ã®æ–‡å­—ã ã‘ã‚’ç·šã§çµã¶
  ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
  ctx.lineWidth = 2;
  for (let body of bodies) {
    if (!body.renderSprite || body.isStatic || body.isEmoji) continue;
    
    for (let other of bodies) {
      if (body.id >= other.id || !other.renderSprite || other.isStatic || other.isEmoji) continue;
      
      const pairId = `${body.id}-${other.id}`;
      if (validPairs.has(pairId)) {
        ctx.beginPath();
        ctx.moveTo(body.position.x, body.position.y);
        ctx.lineTo(other.position.x, other.position.y);
        ctx.stroke();
      }
    }
  }

  // å„ãƒœãƒ‡ã‚£ã‚’æç”»
  for (let body of bodies) {
    ctx.save();
    ctx.translate(body.position.x, body.position.y);
    ctx.rotate(body.angle);

    // å½¢çŠ¶ã‚’æç”»ï¼ˆå½“ãŸã‚Šåˆ¤å®šï¼‰
    // ctx.beginPath();
    // const vertices = body.vertices;
    // ctx.moveTo(vertices[0].x - body.position.x, vertices[0].y - body.position.y);
    // for (let i = 1; i < vertices.length; i++) {
    //   ctx.lineTo(vertices[i].x - body.position.x, vertices[i].y - body.position.y);
    // }
    // ctx.closePath();
    // ctx.fillStyle = body.render.fillStyle || '#fff';
    // ctx.fill();
    // ctx.strokeStyle = body.render.strokeStyle || '#666';
    // ctx.lineWidth = body.render.lineWidth || 1;
    // ctx.stroke();

    // æ–‡å­—æç”»
    if (body.renderSprite) {
      // åŸºæœ¬ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º
      const baseFontSize = body.isEmoji ? 48 : 32;
      
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã®æ–‡å­—ã‚’å–å¾—
      const shouldHighlight = bodyHighlights.get(body) || false;
      
      // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®è¨ˆç®—ï¼ˆèµ¤è‰²ã®æ™‚æ‹¡å¤§ï¼‰
      let targetSize = baseFontSize;
      if (shouldHighlight && !body.isEmoji) {
        targetSize = baseFontSize * 1.15;
      }
      
      // ç¾åœ¨ã®ã‚µã‚¤ã‚ºã‚’ä¿æŒï¼ˆåˆå›ã¯åŸºæœ¬ã‚µã‚¤ã‚ºï¼‰
      if (!body.currentFontSize) {
        body.currentFontSize = baseFontSize;
      }
      
      // ã‚¹ãƒ ãƒ¼ã‚ºã«è£œé–“ï¼ˆã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼‰
      const lerpSpeed = 0.15;
      body.currentFontSize += (targetSize - body.currentFontSize) * lerpSpeed;
      
      ctx.font = `bold ${Math.round(body.currentFontSize)}px sans-serif`;
      ctx.fillStyle = shouldHighlight ? "#FF6B6B" : "#000";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(body.renderSprite, 0, 0);
    }

    ctx.restore();
  }
  
  // ä¸­å¤®è¡¨ç¤ºã®ç®¡ç†ï¼ˆDELETEã¨åˆæˆè¡¨ç¤ºã‚’çµ±åˆï¼‰
  const currentTime = Date.now();
  let displayText = '';
  let displayColor = '';
  let displayStartTime = 0;
  
  if (deleteActive) {
    displayText = 'DELETE';
    displayColor = 'rgba(255, 0, 0, '; //èµ¤ç³»ã®è‰²
    displayStartTime = deleteStartTime;
  } else if (mergeDisplayText) {
    displayText = mergeDisplayText;
    displayColor = 'rgba(100, 200, 255, '; // é’ç³»ã®è‰²
    displayStartTime = mergeDisplayStartTime;
  }
  
  if (displayText) {
    const elapsed = currentTime - displayStartTime;
    const displayDuration = 2000; // 2ç§’é–“è¡¨ç¤º
    
    if (elapsed < displayDuration) {
      // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ
      const alpha = Math.max(0, 1 - elapsed / displayDuration);
      
      ctx.save();
      ctx.font = "bold 120px sans-serif";
      ctx.fillStyle = displayColor + alpha + ')';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(displayText, canvas.width / 2, canvas.height / 2);
      ctx.restore();
    } else {
      // è¡¨ç¤ºçµ‚äº†
      if (deleteActive) {
        deleteActive = false;
        // åœ°é¢ã‚’å¾©æ´»
        if (!ground) {
          ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight-20, window.innerWidth, 40, { 
            isStatic: true,
            restitution: 0.5
          });
          Composite.add(world, ground);
        }
      } else {
        mergeDisplayText = '';
      }
    }
  }
})();
</script>

</body>
</html>
